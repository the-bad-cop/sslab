FCFS ALGORITHM
#include<stdio.h>
void main(){
 int pno;
 int burst[20];
 int arrival[20];
 int pid[20];
 int i=0,j=0;
 int sum=0;
 int wait[20];
 int turn[20];
 printf("Enter the no .of processes");
 scanf("%d",&pno);
 while(i<pno){
 printf("Enter the pid");
 scanf("%d",&pid[i]);
 printf("Enter the burst time");
 scanf("%d",&burst[i]);
 printf("Enter the arrival time");
 scanf("%d",&arrival[i]);
 i++;
 }
 wait[0]=0;
 wait[1]=burst[0];
 for(i=2;i<pno;i++){
 for(j=0;j<i;j++){
 wait[i]+=burst[j];
 }
 wait[i]=wait[i]-arrival[i];
 }
 for(i=0;i<pno;i++){
 sum=sum+wait[i];
 }
 printf("Avg waiting time %d\n",sum/pno);
 sum=0;
 for(i=0;i<pno;i++){
 turn[i]=burst[i]+wait[i];
 sum=sum+turn[i];
 }
 printf("Avg turnaround time %d\n",sum/pno);
}
SHORTEST JOB FIRST PROGRAM
#include <stdio.h>
void main(){
int pno=0, i=0,j=0,burst[20], arrival[20], pid[20],wait[20],turn[20],min=0;
float sum=0.0,avg =0.0;
int temp1=0,temp2=0,temp3=0;
printf("Enter the no.of processess");
scanf("%d",&pno);
while(i<pno){
printf("Enter the pid ");
 scanf("%d",&pid[i]);
printf("Enter the burst time ");
 scanf("%d",&burst[i]);
 printf("Enter the arrival time ");
 scanf("%d",&arrival[i]);
i++;
}
for(i=1;i<pno;i++){
min=i;
for(j=i+1;j<pno;j++){
if(burst[j]<burst[min]){
min=j;
}
}
temp1=burst[i];
temp2=arrival[i];
temp3=pid[i];
burst[i]=burst[min];
arrival[i]=arrival[min];
pid[i]=pid[min];
arrival[min]=temp2;
burst[min]=temp1;
pid[min]=temp3;
}
wait[0]=0;
 wait[1]=burst[0]+arrival[0]-arrival[1];
 for(i=2;i<pno;i++){
wait[i]=0;
 for(j=0;j<i;j++){
 wait[i]+=burst[j];
 }
 wait[i]=wait[i]+arrival[0]-arrival[i];
 }
 for(i=0;i<pno;i++){
 sum=sum+wait[i];
 }
avg=sum/pno;
 printf("Avg waiting time %f\n",avg);
 sum=0;
 for(i=0;i<pno;i++){
 turn[i]=burst[i]+wait[i];
 sum=sum+turn[i];
 }
 printf("Avg turnaround time %f\n",sum/pno);
PRIORITY CPU SCHEDULING PROGRAM
#include<stdio.h>
void main()
{
int n,small,p[20],a[20],w[20],b[20],t[20],g[20],i,j,temp;
float aww=0,att=0;
printf("Enter number of process==\n");
scanf("%d",&n);
printf("Enter burst time==\n");
for(i=0;i<n;i++)
scanf("%d",&b[i]);
printf("Enter Arrival time==\n");
for(i=0;i<n;i++)
scanf("%d",&a[i]);
printf("Enter priority==\n");
for(i=0;i<n;i++)
scanf("%d",&p[i]);
for(i=0;i<n;i++)
{
small=i;
for(j=i;j<n;j++)
{
if(p[small]>p[j])
small=j;
}
temp=p[i];
p[i]=p[small];
p[small]=temp;
temp=b[i];
b[i]=b[small];
b[small]=temp;
temp=a[i];
a[i]=a[small];
a[small]=temp;
}
g[0]=0;
for(i=0;i<n;i++)
g[i+1]=g[i]+b[i];
for(i=0;i<n;i++)
{
w[i]=g[i]-a[i];
t[i]=g[i+1]-a[i];
aww=aww+w[i];
att=att+t[i];
}
aww=aww/n;
att=att/n;
printf("\tARRIVALTIME\tBURSTTIME\tPRIORITY\n\n\n\n\n");
for(i=0;i<n;i++)
printf("\t%d\t\t%d\t\t%d\n\n",a[i],b[i],p[i]);
printf("Avg Waiting time==%f\n\n",aww);
printf("Avg Turnaroundtime==%f\n\n",att);
}
ROUND ROBIN CPU SCHEDULING PROGRAM
#include <stdio.h>
int isFinish(int burst[],int n);
int isFinish(int burst[],int n){

 int i=0;
 for(i=0;i<n;i++){
 if(burst[i]>0){
 return 0;
 }
 }
 return 1;
}
int main(){
 int i=0,j=0,time=0,n=6,b=0;
 int g=0;
 int arrival[6]={0,1,2,3,4,6},burst[6]={4,5,2,1,6,3},wait[20];
 int temp[200][2];
 int queue[30],front=-1,rear=-1;
 int qw[20];
 int q=2;
 float sum=0.0,avg=0.0,turn=0.0;
int pop(){
 int item=0;
 if(front==-1){
 printf("Queue is empty");
 return -1;
 }else{
 item=queue[front];
 if(front==rear){
 front=-1;
 rear=-1;
 }else{
 front=front+1;
 }
 return item;
 printf("%d ",item);
 }
}
int push(int item){

 if(rear==30){
 printf("Full");
 return -1;
 }else{
 if(front==-1 && rear==-1){
 front=0;
 }
 rear=rear+1;
 queue[rear]=item;
 }
}

 j=0;
 time=0;
 push(0);
 i=0;
 while(front!=-1){
 g=pop();
 i=0;
 if(time<arrival[n-1]){
 while(i<n){
 if(arrival[i]>time && arrival[i]<=(time+q)&& i!=g){
 push(i);
 printf("%d i \n",i);
 }
 i++;
 }
 }

 temp[j][0]=g;
 if(burst[g]>q){
 temp[j][1]=q;
 time=time+q;
 burst[g]=burst[g]-q;
 j=j+1;
 push(g);
 }else if(burst[g]>0 && burst[g]<=q){
 temp[j][1]=burst[g];
 time=time+burst[g];
 burst[g]=0;
 j=j+1;
 }
 }
 b=j;
 for(i=0;i<n;i++){
 wait[i]=0-arrival[i];
 qw[i]=0;
 }
 time=0;
 for(i=0;i<b;i++){
 wait[temp[i][0]]=wait[temp[i][0]]+time-qw[temp[i][0]];
 time=temp[i][1]+time;
 qw[temp[i][0]]=time;
 }
 for(i=0;i<n;i++){
 sum=sum+wait[i];
 printf("\n %d %d",wait[i],qw[i]);
 turn=turn+qw[i]-arrival[i];
 }
 printf("\n %f %f",sum,turn);
 avg=sum/n;
 turn=turn/n;
 printf("\n %f %f",avg,turn);
} 
BANKERS ALGORITHM
#include<stdio.h>
void check();
int finish[10],avail[10],max[10][10],all[10][10],need[10][10],work[10],seq[10];
int p=0,r=0,a=0,i=0,k=0,j=0,l=0,g=0,h=0,b=0,req[10];
void main(){
 printf("\nEnter the no of processes");
 scanf("%d",&p);
 printf("\nEnter the no of resources");
 scanf("%d",&r);
 printf("\nEnter the no of available resources ");
 for (i=0;i<r;i++){
 scanf("%d",&avail[i]);
 work[i]=avail[i];
 }
 printf("\nEnter the no of allocated resources");
 for(i=0;i<p;i++){
 for(j=0;j<r;j++){
 scanf("%d",&all[i][j]);
 }
 }
 printf("\nEnter the no of maximum resources");
 for(i=0;i<p;i++){
 for(j=0;j<r;j++){
 scanf("%d",&max[i][j]);
 need[i][j]=max[i][j]-all[i][j];
 }
 finish[i]=0;
 }
 check();
 printf("\nEnter process requesting for res");
 scanf("%d",&h);
 for(i=0;i<r;i++){
 scanf("%d",&req[i]);
 }
 for(i=0;i<r;i++){
 if(need[h][i]>=req[i]){
 b=1;
 }else{
 b=0;
 break;
 }
 }
 if(b){
 for(i=0;i<r;i++){
 if(avail[i]>=req[i]){
 b=1;
 }else{
 b=0;
 break;
 }
 }
 if(b){
 for(i=0;i<r;i++){
 avail[i]=avail[i]-req[i];
 all[h][i]=all[h][i]+req[i];
 need[h][i]=need[h][i]-req[i];
 }
 check();
 }
}
}
void check(){
 a=0;
 for(i=0;i<p;i++){
 for(j=0;j<p;j++){
 g=0;
 for(k=0;k<r;k++){
 if(need[j][k]<=work[k] && finish[j]==0){
 g=1;
 }else
 {
 g=0;
 break;
 }
 }
 if(g==1){
 finish[j]=1;
 for(k=0;k<r;k++){
 work[k]=work[k]+all[j][k];

 }
 seq[a++]=j;
 break;
 }
 }
 }
 l=0;
 for(i=0;i<p;i++){
 if(finish[i]){
 l=1;
 }
 else{
 l=0;
 break;
 }
 }
 if(l){
 for(i=0;i<p;i++){
 printf("p%d->",seq[i]);
 }
 }
return;
}
FCFS DISK SCHEDULING PROGRAM
#include <stdio.h>
void main(){
int n=0,i=0,head=0,sum=0;
float o=0.0,k=5.0;
int p[20];
printf("Enter the no .of inputs");
scanf("%d",&n);
printf("Enter the inputs");
for(i=0;i<n;i++){
scanf("%d",&p[i]);
}
printf("Enter the head position");
scanf("%d",&head);
sum=head-p[0];
for(i=0;i<n-1;i++){
sum+=p[i+1]>p[i]? p[i+1]-p[i]:p[i]-p[i+1];
}
printf("Seek time= %d",sum);
o=sum;
o=o/k;
printf("Seek time= %f",o);
}
SCAN DISK SCHEDULING PROGRAM
#include <stdio.h>
 void main(){
int n=5,head=25,temp=0,i=0,j=0,total=0;
float o=0.0, k=0.0;
int p[5]={12,34,23,45,32};
for(i=0;i<n;i++){
for(j=0;j<n;j++){
if(p[i]<p[j]){
temp=p[i];
p[i]=p[j];
p[j]=temp;
}
}
}
total=199-head +199-p[0];
printf("Seek time %d",total);
k=n;
o=total;
o=o/k;
printf("Seek time= %f",o);
}
CSCAN DISK SCHEDULING PROGRAM
#include <stdio.h>
 void main(){
int n=8,head=53,temp=0,i=0,j=0,total=0;
int p[8]={98,183,37,122,14,124,65,67};
float o,k;
for(i=0;i<n;i++){
for(j=0;j<n;j++){
if(p[i]<p[j]){
temp=p[i];
p[i]=p[j];
p[j]=temp;
}
}
}
for (i=0;i<n;i++){
if(p[i]>head){
break;
}
}
total=(199-head)+p[i-1];
printf("Seek time %d",total);
k=n;
o=total;
o=o/k;
printf(" Avg Seek time= %f",o);
}
PRODUCER CONSUMER PROBLEM
#include<stdio.h>
#include<stdlib.h>
int mutex=1,full=0,empty,x=0;
int main()
{
printf(" Enter size of buffer ");
scanf("%d",&empty);
int n;
void producer();
void consumer();
int dec(int);
int inc(int);
printf("\n1.Producer\n2.Consumer\n3.Exit");
while(1)
{
printf("\nEnter your choice:");
scanf("%d",&n);
switch(n)
{
case 1: if((mutex==1)&&(empty!=0))
producer();
else
printf("Buffer is full!!");
break;
case 2: if((mutex==1)&&(full!=0))
consumer();
else
printf("Buffer is empty!!");
break;
case 3:
exit(0);
break;
}
}
return 0;
}
int dec(int s)
{
return (--s);
}
int inc(int s)
{
return(++s);
}
void producer()
{
mutex=dec(mutex);
full=inc(full);
empty=dec(empty);
x++;
printf("\nProducer produces the item %d",x);
mutex=inc(mutex);
}
void consumer()
{
mutex=dec(mutex);
full=dec(full);
empty=inc(empty);
printf("\nConsumer consumes item %d",x);
x--;
mutex=inc(mutex)
}
THE DINING PHILOSOPHERâ€™S PROBLEM
#include<stdio.h>
int chopstick[10],n,state[10];
void p(int s){
 chopstick[s]--;
}
void v(int s){
 chopstick[s]++;
}
void print(){
 int i;
 for(i=0;i<n;i++){
 if(state[i]==0)printf("\nPhilosopher is thinking");
 else if(state[i]==1)printf("\nPhilosopher is hungry;waiting to eat");
 else printf("\nPhilosopher is eating");
 }
}
void dining(int s){
 int x=0;
 if(chopstick[s]!=0){
 p(s);
 if(chopstick[(s+1)%n]!=0){
 p((s+1)%n);
 state[s]=2;
 x=1;
 }
 }
 print(s);
}
void main()
{
 int i,ch,s;
 printf("\Enter the no. of philosophers=");
 scanf("%d",&n);
 for(i=0;i<n;i++)
 {
 chopstick[i]=1;
 state[i]=0;
 }
 do
 {
 printf("\nEnter the professor who are hungry =");
 scanf("%d",&s);
 state[s-1]=1;
 dining(s-1);
 printf("\nDo you want to continue(1/0):");
 scanf("%d",&ch);
 }while(ch);
}
SINGLE LEVEL DIRECTORY
#include<stdlib.h>
#include<string.h>
#include<stdio.h>
struct{
char dname[10],fname[10][10];
int fcnt;
}dir;
void main(){
int i,ch;
char f[30];
dir.fcnt = 0;
printf("\nEnter name of directory -- ");
scanf("%s", dir.dname);
while(1){
printf("\n\n1. Create File\t2. Delete File\t3. Search File \n 4. Display Files\t5. Exit\nEnter your choice -- ");
scanf("%d",&ch);
switch(ch){
case 1: printf("\nEnter the name of the file -- ");
scanf("%s",dir.fname[dir.fcnt]);
dir.fcnt++;
break;
case 2: printf("\nEnter the name of the file -- ");
scanf("%s",f);
for(i=0;i<dir.fcnt;i++){
if(strcmp(f, dir.fname[i])==0)
{
printf("File %s is deleted ",f);
strcpy(dir.fname[i],dir.fname[dir.fcnt-1]); break;
} }
if(i==dir.fcnt) printf("File %s not found",f);
else
dir.fcnt--;
break;
case 3: printf("\nEnter the name of the file -- ");
scanf("%s",f);
for(i=0;i<dir.fcnt;i++)
{
if(strcmp(f, dir.fname[i])==0){
printf("File %s is found ", f);
break;
}
}
if(i==dir.fcnt)
printf("File %s not found",f);
break;
case 4: if(dir.fcnt==0)
printf("\nDirectory Empty");
else{
printf("\nThe Files are -- ");
for(i=0;i<dir.fcnt;i++)
printf("\t%s",dir.fname[i]);
}
break;
}
}
TWO LEVEL DIRECTORY
#include<stdio.h>
#include<string.h>
typedef struct user{
int g;
char name[10];
char dir[10];
char files[10][10];
}User;
 void main(){
User users[10];
int g=0,i=0,j=0,n,m,z;
char null[1]={'\0'};
char temp[10];
void afterlogin(int id){
void display(){
printf("\n The files in directory %s are:\n ",users[id].dir);
i=0;
while(i<users[id].g){
printf("%s\n",users[id].files[i]);
i++;
}
}
void create(){
printf("Enter the file name ");
scanf("%s",temp);
i=0;
while(i<10){
m=strcmp(temp,users[id].files[i]);
if(m==0){
printf("\nFile found cannot be created\n");
return;
}
i++;
}
j=users[id].g++;
strcpy(users[id].files[j],temp);
printf("File created\n");
display();
}
void search(){
i=0;
printf("\nEnter the filename\n");
scanf("%s",temp);
while(i<10){
m=strcmp(temp,users[id].files[i]);
if(m==0){
printf("\nFile found\n");
return;
}
i++;
}
printf("\nFile not Found\n");
return;
}
void delete(){
i=0;
printf("\nEnter the filename to delete\n");
scanf("%s",temp);
while(i<10){
m=strcmp(temp,users[id].files[i]);
if(m==0){
strcpy(users[id].files[i],null);
printf("\nfile deleted\n");
return;
}
i++;
}
printf("\nFile not Found\n");
return;
}
while(1){
printf("Choose an option:\n");
printf("1.Create file\n2.Search file\n3.Delete file\n 4.Display files\n5.go back\n");
scanf("%d",&n);
switch(n){
case 1:
create();
break;
case 2:
search();
break;
case 3:
delete();
break;
case 4:
display();
break;
case 5:
break;
default:
printf("\nEnter a valid option\n");
break;
}
if(n==5){
break;
}
}
printf("\n");
}
void createUser(){
printf("Enter the username");
scanf("%s",temp);
strcpy(users[g].name,temp);
users[g].g=0;
printf("Enter the dirname for %s",temp);
scanf("%s",temp);
}
void login(){
printf("Enter the username");
scanf("%s",temp);
i=0;
while(i<10){
int m=strcmp(users[i].name,temp);
if(m==0){
afterlogin(i);
return;
}
i++;
}
printf("\nInvalid username\n");
return;
}
while(1){
printf("Choose an option:\n");
printf("1.Create User\n2.go to User\n5.Exit\n");
scanf("%d",&z);
switch(z){
case 1:
createUser();
break;
case 2:
login();
break;
default:
printf("\nEnter a valid option\n");
break;
}
if(z==5){
break;
}
}
}
FIFO PAGE REPALCEMENT PROGRAM
#include<stdio.h>
void main(){
 int f,p,pg[10],pf=0,i,c,frame[10],j,t=0,x=0;
 printf("\nenter the frame size: ");
 scanf("%d",&f);
 printf("\nEnter the no. of pages: ");
 scanf("%d",&p);
 printf("\nEnter the pages: ");
 for(i=0;i<p;i++)scanf("%d",&pg[i]);
 c=0;
 i=0;
 while(i<p){
while(c<f){
 frame[c++]=pg[i++];
 pf++;
}
 t=0;
 if(c==f){
 for(j=0;j<f;j++){
 if(pg[i]==frame[j])
 t=1;
 }
 j=x;
 if(t==0){
 frame[j]=pg[i];
 x++;
 pf++;
 if(x==f)
 x=0;
 }
 i++;
 }
}
printf("\nThe no. of page faults=%d\n",pf);
}
LRU PAGE REPLACEMENT PROGRAM
#include<stdio.h>
void main(){
 int lru[5][3],p=3,l=0,i,j,k,a=0,n,pg=0,min,min1,in[10];
 printf("Enter the no.of pages\n");
 scanf("%d",&n);
 printf("Enter the reference string");
 k=0;
 for(i=0;i<3;i++){
 for(j=0;j<3;j++){
 lru[i][j]=-1;
 }}
 while(k<n){
 scanf("%d",&in[k]);
 k++;
 }
l=0;
 for(i=0;i<n;i++){
 a=0;
 k=0;
 if(i<p){
 while(k<p){
 if(in[i]==lru[k][0]){
 lru[k][1]++;
 lru[k][2]=i;
 a=1;
 break;
 }
 k++;
 }
 if(a==0){
 lru[l][0]=in[i];
 lru[l][1]=0;
 lru[l++][2]=i;
 pg++;
 }
 }else{
 while(k<p){
 if(in[i]==lru[k][0]){
 lru[k][1]++;
 lru[k][2]=i;
 a=1;
 break;
 }
 k++;
 }
 if(a==0){
 j=0;
 min=lru[0][1];
 k=0;
 while(k<p){
 if(lru[k][1]<min){
 min=lru[k][1];
 }
 k++;
 }
 k=0;
 min1=lru[0][2];
 while(k<p){
 if(lru[k][2]<=min1 & lru[k][1]==min){
 min1=lru[k][2];
 l=k;
 }
 k++;
 }
 lru[l][0]=in[i];
 lru[l][1]=0;
 lru[l][2]=i;
 pg++;
 }
 }
 }
printf("\nThe no of page faults = %d",pg);
}
PASS 1 OF TWO PASS ASSEMBLER
#include<stdio.h>
#include <stdlib.h>
#include <string.h>
void main(){
FILE *in,*op,*sym,*inter;
char label[20],opcode[20],unwant[20],operandstr[20],aux[20];
int locc=0,start,operand,len=0,f;
in=fopen("input.txt","r");
sym=fopen("symtab.txt","w+");
inter=fopen("intermediate.txt","w");
op=fopen("optab.txt","r");
fscanf(in,"%s %s %s",label,opcode,operandstr);
if(strcmp(opcode,"START")==0){
start=atoi(operandstr);
locc=start;
fprintf(inter,"%d\t%s\t%s\t%s\n",locc,label,opcode,operandstr);
fscanf(in,"%s %s %s",label,opcode,operandstr);
}else{
locc=0;
}
while(strcmp(opcode,"END")!=0){
f=1;
fseek(sym, 0, SEEK_SET);
if(strcmp(label,"-")!=0){
while(!feof(sym)){
fscanf(sym,"%s %s",aux,unwant);
if(strcmp(aux,label)==0){
printf("Error");
f=0;
break;
}
}
fseek(sym, 0, SEEK_END);
if(f==1){
fprintf(sym,"%s\t%d\n",label,locc);
}
}
f=0;
fseek(op, 0, SEEK_SET);
while(!feof(op)){
fscanf(op,"%s %s",aux,unwant);
if(strcmp(aux,opcode)==0){\
fprintf(inter,"%d\t%s\t%s\t%s\n",locc,label,opcode,operandstr);
locc=locc+3;
f=1;
break;
}
}
if(f==0){
if(strcmp(opcode,"WORD")==0){
fprintf(inter,"%d\t%s\t%s\t%s\n",locc,label,opcode,operandstr);
locc=locc+3;
}
else if(strcmp(opcode,"RESW")==0){
fprintf(inter,"%d\t%s\t%s\t%s\n",locc,label,opcode,operandstr);
locc=locc+3*(atoi(operandstr));
}
else if(strcmp(opcode,"RESB")==0){
fprintf(inter,"%d\t%s\t%s\t%s\n",locc,label,opcode,operandstr);
locc=locc+(atoi(operandstr));
}
else if(strcmp(opcode,"BYTE")==0){
//printf("75 %d\t%s\n",locc,opcode);
if(operandstr[0]=='X'){
fprintf(inter,"%d\t%s\t%s\t%s\
n",locc,label,opcode,operandstr);
locc=locc+1;
}
 else
 {
 fprintf(inter,"%d\t%s\t%s\t%s\
n",locc,label,opcode,operandstr);
 len=strlen(operandstr)-2;
 locc=locc+len;
}
}
else{
printf("Error 85");
}
}
fscanf(in,"%s %s %s",label,opcode,operandstr);
}
fprintf(inter,"%d\t%s\t%s\t%d\n",locc,"-",opcode,start);
}
PASS 2 OF TWO PASS ASSEMBLER
#include<stdio.h>
#include <stdlib.h>
#include <string.h>
void main(){
 FILE *op,*sym,*inter,*object,*assm;
char label[20],opcode[20],unwant[20],operandstr[20],aux[20],addr[20],ope[10];
int lo=0,start=0,operand,add,pc,opadd,fop,fsym,len=0,f,qw=0,i=0;
inter=fopen("intermediate.txt","r");
sym=fopen("symtab.txt","r");
object=fopen("object.txt","w");
op=fopen("optab.txt","r");
 assm=fopen("assemble.txt","w");
 fscanf(inter,"%s %s %s %s",addr,label,opcode,operandstr);
 if(strcmp(opcode,"START")==0){
 start=atoi(operandstr);
 fprintf(assm,"%s %s %s %s\n",addr,label,opcode,operandstr);
 fprintf(object,"H^%d^%s\n",start,"25");
 fscanf(inter,"%s %s %s %s",addr,label,opcode,operandstr);
 }else{
 printf("Error22");
 }
 fprintf(object,"T^%d^%d^",start,len);
 while(strcmp(opcode,"END")!=0){
 fseek(op, 0, SEEK_SET);
 fop=0;
 while(!feof(op)){
 fscanf(op,"%s %s",aux,unwant);
if(strcmp(aux,opcode)==0){
 strcpy(ope,unwant);
 fop=1;
 fsym=0;
 fseek(sym, 0, SEEK_SET);
 if(strcmp(operandstr,"-")!=0){
 while(!feof(sym)){
 fscanf(sym,"%s %s",aux,unwant);
 if(strcmp(aux,operandstr)==0){
 opadd=atoi(unwant);
 fsym=1;
 break;
 }
 }if(fsym==0){
 printf("Error44");
 opadd=0;
 }
 }
 if(fsym){
 fprintf(object,"%s%d^",ope,opadd);
 fprintf(assm,"%s\t%s\t%s\t%s\t%s%d\n",addr,label,opcode,operandstr,ope,opadd);
 }
 }
 }
 if(fop==0){
 if((strcmp("BYTE",opcode)==0) || (strcmp("WORD",opcode)==0) ){
 if(strcmp(opcode,"WORD")==0){
 fprintf(object,"0000%s^",operandstr);
 fprintf(assm,"%s\t%s\t%s\t%s\t0000%s\n",addr,label,opcode,operandstr,operandstr);
 }
 else
 {
 fprintf(assm,"%s\t%s\t%s\t%s\t",addr,label,opcode,operandstr);
 len=strlen(operandstr);
 for(i=2;i<len;i++)
 {
 fprintf(object,"%d",operandstr[i]);
 fprintf(assm,"%d",operandstr[i]);
 }
 fprintf(object,"^");
 fprintf(assm,"\n");
 }
 }else{
 fprintf(assm,"%s\t%s\t%s\t%s\n",addr,label,opcode,operandstr);
 }
 } fscanf(inter,"%s %s %s %s",addr,label,opcode,operandstr);
 }
 fprintf(object,"\nE^%d\n",start);
}